як що використати
int main(int /*argc*/, char */*argv*/[])
{
  double posX = 22, posY = 12;  //x and y start position
  double dirX = -1, dirY = 0; //initial direction vector
  double planeX = 0, planeY = 0.66; //the 2d raycaster version of camera plane

  double time = 0; //time of current frame
  double oldTime = 0; //time of previous frame
for(int x = 0; x < w; x++)
    {
      //calculate ray position and direction
      double cameraX = 2 * x / double(w) - 1; //x-coordinate in camera space
      double rayDirX = dirX + planeX * cameraX;
      double rayDirY = dirY + planeY * cameraX;
//which box of the map we're in
      int mapX = int(posX);
      int mapY = int(posY);

      //length of ray from current position to next x or y-side
      double sideDistX;
      double sideDistY;

       //length of ray from one x or y-side to next x or y-side
      double deltaDistX = (rayDirX == 0) ? 1e30 : std::abs(1 / rayDirX);
      double deltaDistY = (rayDirY == 0) ? 1e30 : std::abs(1 / rayDirY);
      double perpWallDist;

      //what direction to step in x or y-direction (either +1 or -1)
      int stepX;
      int stepY;

      int hit = 0; //was there a wall hit?
      int side; //was a NS or a EW wall hit?
//calculate step and initial sideDist
      if (rayDirX < 0)
      {
        stepX = -1;
        sideDistX = (posX - mapX) * deltaDistX;
      }
      else
      {
        stepX = 1;
        sideDistX = (mapX + 1.0 - posX) * deltaDistX;
      }
      if (rayDirY < 0)
      {
        stepY = -1;
        sideDistY = (posY - mapY) * deltaDistY;
      }
      else
      {
        stepY = 1;
        sideDistY = (mapY + 1.0 - posY) * deltaDistY;
      }
 //perform DDA
      while (hit == 0)
      {
        //jump to next map square, either in x-direction, or in y-direction
        if (sideDistX < sideDistY)
        {
          sideDistX += deltaDistX;
          mapX += stepX;
          side = 0;
        }
        else
        {
          sideDistY += deltaDistY;
          mapY += stepY;
          side = 1;
        }
        //Check if ray has hit a wall
        if (worldMap[mapX][mapY] > 0) hit = 1;
      }
//Calculate distance projected on camera direction (Euclidean distance would give fisheye effect!)
      if(side == 0) perpWallDist = (sideDistX - deltaDistX);
      else          perpWallDist = (sideDistY - deltaDistY);
 //Calculate height of line to draw on screen
      int lineHeight = (int)(h / perpWallDist);

      //calculate lowest and highest pixel to fill in current stripe
      int drawStart = -lineHeight / 2 + h / 2;
      if(drawStart < 0)drawStart = 0;
      int drawEnd = lineHeight / 2 + h / 2;
      if(drawEnd >= h)drawEnd = h - 1;
 //choose wall color
      ColorRGB color;
      switch(worldMap[mapX][mapY])
      {
        case 1:  color = RGB_Red;  break; //red
        case 2:  color = RGB_Green;  break; //green
        case 3:  color = RGB_Blue;   break; //blue
        case 4:  color = RGB_White;  break; //white
        default: color = RGB_Yellow; break; //yellow
      }

      //give x and y sides different brightness
      if (side == 1) {color = color / 2;}

      //draw the pixels of the stripe as a vertical line
      verLine(x, drawStart, drawEnd, color);
    }
 //timing for input and FPS counter
    oldTime = time;
    time = getTicks();
    double frameTime = (time - oldTime) / 1000.0; //frameTime is the time this frame has taken, in seconds
    print(1.0 / frameTime); //FPS counter
    redraw();
    cls();

    //speed modifiers
    double moveSpeed = frameTime * 5.0; //the constant value is in squares/second
    double rotSpeed = frameTime * 3.0; //the constant value is in radians/second
    readKeys();
    //move forward if no wall in front of you
    if (keyDown(SDLK_UP))
    {
      if(worldMap[int(posX + dirX * moveSpeed)][int(posY)] == false) posX += dirX * moveSpeed;
      if(worldMap[int(posX)][int(posY + dirY * moveSpeed)] == false) posY += dirY * moveSpeed;
    }
    //move backwards if no wall behind you
    if (keyDown(SDLK_DOWN))
    {
      if(worldMap[int(posX - dirX * moveSpeed)][int(posY)] == false) posX -= dirX * moveSpeed;
      if(worldMap[int(posX)][int(posY - dirY * moveSpeed)] == false) posY -= dirY * moveSpeed;
    }
    //rotate to the right
    if (keyDown(SDLK_RIGHT))
    {
      //both camera direction and camera plane must be rotated
      double oldDirX = dirX;
      dirX = dirX * cos(-rotSpeed) - dirY * sin(-rotSpeed);
      dirY = oldDirX * sin(-rotSpeed) + dirY * cos(-rotSpeed);
      double oldPlaneX = planeX;
      planeX = planeX * cos(-rotSpeed) - planeY * sin(-rotSpeed);
      planeY = oldPlaneX * sin(-rotSpeed) + planeY * cos(-rotSpeed);
    }
    //rotate to the left
    if (keyDown(SDLK_LEFT))
    {
      //both camera direction and camera plane must be rotated
      double oldDirX = dirX;
      dirX = dirX * cos(rotSpeed) - dirY * sin(rotSpeed);
      dirY = oldDirX * sin(rotSpeed) + dirY * cos(rotSpeed);
      double oldPlaneX = planeX;
      planeX = planeX * cos(rotSpeed) - planeY * sin(rotSpeed);
      planeY = oldPlaneX * sin(rotSpeed) + planeY * cos(rotSpeed);
    }
  }
}

для покращення мого коду
bool	map_vision_wall_collision(t_point line)
{
	t_data	*data;
	char	**mapa;
	t_point	map;
	t_point	map_max;

	data = get_data();
	mapa = data->map.map;
	map_max.x = data->map.width * data->tile_size;
	map_max.y = data->map.height * data->tile_size;
	if (line.x < 0 || line.y < 0 || line.x >= map_max.x || line.y >= map_max.y)
		return (true);
	map.x = (line.x) / data->tile_size;
	map.y = (line.y) / data->tile_size;
	if (mapa[(int)map.y][(int)map.x] == WALL ||
			mapa[(int)map.y][(int)map.x] == VOID)
		return (true);
	return (false);
}

void	calculate_vision_point(t_player player, t_point *pos,
		int distance, float graus)
{
	double	degree_rad;

	degree_rad = degrees_to_radians(graus);
	pos->x = player.pos.x + distance * cos(degree_rad);
	pos->y = player.pos.y + distance * sin(degree_rad);
}

// ---------------------------------agora---------------------------------------

void	draw_dda_line(t_point pos, t_point vp, double *distance, int cor)
{
	t_point	delta;
	t_point	step;
	t_point	line;
	double	steps;
	int		i;

	delta.x = vp.x - pos.x;
	delta.y = vp.y - pos.y;
	steps = fmax(fabs(delta.x), fabs(delta.y));
	line.x = pos.x;
	line.y = pos.y;
	step.x = delta.x / steps;
	step.y = delta.y / steps;
	i = 0;
	while (i < steps)
	{
		if (map_vision_wall_collision(line) == true)
			break ;
		line.x += step.x;
		line.y += step.y;
		*distance += sqrt(step.x * step.x + step.y * step.y);
		// fprintf(stderr, "%f\n", *distance); //MARK
		i++;
	}
	draw_line_on_map(cor, 1, pos, line);
}

void	draw_wall_slise(int x, int wall_height, int cor)
{
	t_data *data;
	int		start;
	int		end;

	data = get_data();
	start = (data->win_height - wall_height) / 2;
	end = (data->win_height + wall_height) / 2;
	draw_line2(x, start, x, end, cor, 1);
	draw_line2(x, 0, x, start, LIGHT_BLUE_COLOR, 1);
	draw_line2(x, end, x, data->win_height, LIGHT_GREEN_COLOR, 1);
}

void	draw_vision_line(t_data *data)
{
	t_player	player;
	t_point		vp;
	int			fov;
	double		wall_hieght;
	double		screen_x;
	double		distance;
	double		ray_angl;

	fov = 60;
	screen_x = 0;
	player = data->player;
	player.pos.x *= data->tile_size;
	player.pos.y *= data->tile_size;
	player.pos.x += player.rendered_size / 2;
	player.pos.y += player.rendered_size / 2;
	while (screen_x < data->win_width)
	{
		ray_angl = player.direction + ((fov * (double)(screen_x - data->win_width / 2) / data->win_width));
		calculate_vision_point(player, &vp, 3000, ray_angl);
		distance = 0;
		draw_dda_line(player.pos, vp, &distance, PURPLE_COLOR);
		distance *= cos(degrees_to_radians(ray_angl - player.direction));
		if (distance > 0)
		{
			wall_hieght = (int)(data->tile_size / distance * data->win_height);
			draw_wall_slise(screen_x, wall_hieght, WALL_COLOR);
		}
		screen_x++;
	}
}

void	player_render(void)
{
	t_data	*data;

	data = get_data();
	draw_vision_line(data);
	draw_full_square(data->player.color, data->screen_width / 2,
		data->screen_height / 2, data->player.rendered_size);
}
bool	map_wall_collision(double x, double y, char c)
{
	t_data	*data;
	char	**map;
	int		pos_y;
	int		pos_x;

	data = get_data();
	map = data->map.map;
	pos_y = 0;
	while (map[pos_y])
	{
		pos_x = 0;
		while (map[pos_y][pos_x])
		{
			if (map[pos_y][pos_x] == c)
			{
				if (squares_touch((t_point){x, y}, data->player.size,
						(t_point){pos_x, pos_y}, 1))
				{
					return (true);
				}
			}
			pos_x++;
		}
		pos_y++;
	}
	return (false);
}

void	lerp_movement(t_player *player, double target_x, double target_y, float smoothing_factor)
{
	player->pos.x += (target_x - player->pos.x) * (smoothing_factor);
	player->pos.y += (target_y - player->pos.y) * (smoothing_factor);
}

static void	movement(t_player *player)
{
	double	temp_x;
	double	temp_y;
	double	direction_radians;
	t_data	*data;

	data = get_data();
	temp_x = player->pos.x;
	temp_y = player->pos.y;
	// movement
	direction_radians = degrees_to_radians(player->direction);
	// printf("direction: %f\n", direction_radians); //MARK
	if (player->move_up)
	{
		temp_x += cos(direction_radians) * player->move_speed;
		temp_y += sin(direction_radians) * player->move_speed;
	}
	if (player->move_down)
	{
		temp_x -= cos(direction_radians) * player->move_speed;
		temp_y -= sin(direction_radians) * player->move_speed;
	}
	if (player->move_left)
	{
		temp_x += sin(direction_radians - PI_2) * player->move_speed;
		temp_y -= cos(direction_radians - PI_2) * player->move_speed;
	}
	if (player->move_right)
	{
		temp_x -= sin(direction_radians + PI_2) * player->move_speed;
		temp_y += cos(direction_radians + PI_2) * player->move_speed;
	}
	// movement limitations
	if (map_wall_collision(temp_x, data->player.pos.y, WALL) == false)
		// data->player.pos.x = temp_x;
		lerp_movement(player, temp_x, player->pos.y, 0.2);
	if (map_wall_collision(data->player.pos.x, temp_y, WALL) == false)
		// data->player.pos.y = temp_y;
		lerp_movement(player, player->pos.x, temp_y, 0.2);
}

void	player_logic(void)
{
	t_data		*data;
	t_player	*player;
	float		smoothing_factor;
	float		target_direction;

	data = get_data();
	player = &(data->player);
	smoothing_factor = 0.1;
	// player movement update
	movement(player);
	// player vision update
	// if (player->looking_left)
	// 	player->direction -= player->looking_speed;
	// if (player->looking_right)
	// 	player->direction += player->looking_speed;

	target_direction = player->direction;
	if (player->looking_left)
		target_direction -= player->looking_speed;
	if (player->looking_right)
		target_direction += player->looking_speed;
	player->direction = player->direction + (target_direction - player->direction) * smoothing_factor;

	if (player->direction < 0)
		player->direction += 360;
	if (player->direction > 360)
		player->direction -= 360;
	// player touches lake / save duck
	if (map_wall_collision(data->player.pos.x, data->player.pos.y, LAKE) == true
		&& player->holding > 0)
	{
		player->holding--;
		ft_printf("\a");
		data->caught_ducks++;
	}
	// player save all ducks
	if (data->caught_ducks >= data->duck_amount && data->duck_amount > 0)
	{
		close_window(NULL);
	}
}
void	draw_line(int x1, int y1, int x2, int y2, int color,
		int thickness)
{
	int	dx;
	int	dy;
	int	sx;
	int	sy;
	int	err;
	int	e2;
	int	i;
	int	j;

	dx = abs(x2 - x1);
	dy = abs(y2 - y1);
	sx = (x1 < x2) ? 1 : -1;
	sy = (y1 < y2) ? 1 : -1;
	err = (dx > dy ? dx : -dy) / 2;
	while (1)
	{
		i = -thickness / 2;
		while (i <= thickness / 2)
		{
			j = -thickness / 2;
			while (j <= thickness / 2)
			{
				put_pixel_to_image(x1 + i, y1 + j, color);
				j++;
			}
			i++;
		}
		if (x1 == x2 && y1 == y2)
			break ;
		e2 = err;
		if (e2 > -dx)
		{
			err -= dy;
			x1 += sx;
		}
		if (e2 < dy)
		{
			err += dx;
			y1 += sy;
		}
	}
}
void	put_pixel_to_image2(int x, int y, int color)
{
	char	*dst;
	t_data	*data;

	data = get_data();
	if ((x > 0 && x < data->win_width) && (y > 0 && y < data->win_height))
	{
		dst = data->mlx.img_data2 + (y * data->mlx.line_length + x * (data->mlx.bpp / 8));
		*(unsigned int *)dst = color;
	}
}
